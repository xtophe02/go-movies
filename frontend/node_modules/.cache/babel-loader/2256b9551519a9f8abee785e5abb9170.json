{"ast":null,"code":"import { registerListeners, unregisterListeners } from './lib/event.js';\nimport { formatDate } from './lib/date-format.js';\nimport Datepicker from './Datepicker.js'; // filter out the config options inapproprite to pass to Datepicker\n\nfunction filterOptions(options) {\n  const newOpts = Object.assign({}, options);\n  delete newOpts.inputs;\n  delete newOpts.allowOneSidedRange;\n  delete newOpts.maxNumberOfDates; // to ensure each datepicker handles a single date\n\n  return newOpts;\n}\n\nfunction setupDatepicker(rangepicker, changeDateListener, el, options) {\n  registerListeners(rangepicker, [[el, 'changeDate', changeDateListener]]);\n  new Datepicker(el, options, rangepicker);\n}\n\nfunction onChangeDate(rangepicker, ev) {\n  // to prevent both datepickers trigger the other side's update each other\n  if (rangepicker._updating) {\n    return;\n  }\n\n  rangepicker._updating = true;\n  const target = ev.target;\n\n  if (target.datepicker === undefined) {\n    return;\n  }\n\n  const datepickers = rangepicker.datepickers;\n  const setDateOptions = {\n    render: false\n  };\n  const changedSide = rangepicker.inputs.indexOf(target);\n  const otherSide = changedSide === 0 ? 1 : 0;\n  const changedDate = datepickers[changedSide].dates[0];\n  const otherDate = datepickers[otherSide].dates[0];\n\n  if (changedDate !== undefined && otherDate !== undefined) {\n    // if the start of the range > the end, swap them\n    if (changedSide === 0 && changedDate > otherDate) {\n      datepickers[0].setDate(otherDate, setDateOptions);\n      datepickers[1].setDate(changedDate, setDateOptions);\n    } else if (changedSide === 1 && changedDate < otherDate) {\n      datepickers[0].setDate(changedDate, setDateOptions);\n      datepickers[1].setDate(otherDate, setDateOptions);\n    }\n  } else if (!rangepicker.allowOneSidedRange) {\n    // to prevent the range from becoming one-sided, copy changed side's\n    // selection (no matter if it's empty) to the other side\n    if (changedDate !== undefined || otherDate !== undefined) {\n      setDateOptions.clear = true;\n      datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);\n    }\n  }\n\n  datepickers[0].picker.update().render();\n  datepickers[1].picker.update().render();\n  delete rangepicker._updating;\n}\n/**\n * Class representing a date range picker\n */\n\n\nexport default class DateRangePicker {\n  /**\n   * Create a date range picker\n   * @param  {Element} element - element to bind a date range picker\n   * @param  {Object} [options] - config options\n   */\n  constructor(element) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll('input'));\n\n    if (inputs.length < 2) {\n      return;\n    }\n\n    element.rangepicker = this;\n    this.element = element;\n    this.inputs = inputs.slice(0, 2);\n    this.allowOneSidedRange = !!options.allowOneSidedRange;\n    const changeDateListener = onChangeDate.bind(null, this);\n    const cleanOptions = filterOptions(options); // in order for initial date setup to work right when pcicLvel > 0,\n    // let Datepicker constructor add the instance to the rangepicker\n\n    const datepickers = [];\n    Object.defineProperty(this, 'datepickers', {\n      get() {\n        return datepickers;\n      }\n\n    });\n    setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);\n    setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);\n    Object.freeze(datepickers); // normalize the range if inital dates are given\n\n    if (datepickers[0].dates.length > 0) {\n      onChangeDate(this, {\n        target: this.inputs[0]\n      });\n    } else if (datepickers[1].dates.length > 0) {\n      onChangeDate(this, {\n        target: this.inputs[1]\n      });\n    }\n  }\n  /**\n   * @type {Array} - selected date of the linked date pickers\n   */\n\n\n  get dates() {\n    return this.datepickers.length === 2 ? [this.datepickers[0].dates[0], this.datepickers[1].dates[0]] : undefined;\n  }\n  /**\n   * Set new values to the config options\n   * @param {Object} options - config options to update\n   */\n\n\n  setOptions(options) {\n    this.allowOneSidedRange = !!options.allowOneSidedRange;\n    const cleanOptions = filterOptions(options);\n    this.datepickers[0].setOptions(cleanOptions);\n    this.datepickers[1].setOptions(cleanOptions);\n  }\n  /**\n   * Destroy the DateRangePicker instance\n   * @return {DateRangePicker} - the instance destroyed\n   */\n\n\n  destroy() {\n    this.datepickers[0].destroy();\n    this.datepickers[1].destroy();\n    unregisterListeners(this);\n    delete this.element.rangepicker;\n  }\n  /**\n   * Get the start and end dates of the date range\n   *\n   * The method returns Date objects by default. If format string is passed,\n   * it returns date strings formatted in given format.\n   * The result array always contains 2 items (start date/end date) and\n   * undefined is used for unselected side. (e.g. If none is selected,\n   * the result will be [undefined, undefined]. If only the end date is set\n   * when allowOneSidedRange config option is true, [undefined, endDate] will\n   * be returned.)\n   *\n   * @param  {String} [format] - Format string to stringify the dates\n   * @return {Array} - Start and end dates\n   */\n\n\n  getDates() {\n    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    const callback = format ? date => formatDate(date, format, this.datepickers[0].config.locale) : date => new Date(date);\n    return this.dates.map(date => date === undefined ? date : callback(date));\n  }\n  /**\n   * Set the start and end dates of the date range\n   *\n   * The method calls datepicker.setDate() internally using each of the\n   * arguments in start→end order.\n   *\n   * When a clear: true option object is passed instead of a date, the method\n   * clears the date.\n   *\n   * If an invalid date, the same date as the current one or an option object\n   * without clear: true is passed, the method considers that argument as an\n   * \"ineffective\" argument because calling datepicker.setDate() with those\n   * values makes no changes to the date selection.\n   *\n   * When the allowOneSidedRange config option is false, passing {clear: true}\n   * to clear the range works only when it is done to the last effective\n   * argument (in other words, passed to rangeEnd or to rangeStart along with\n   * ineffective rangeEnd). This is because when the date range is changed,\n   * it gets normalized based on the last change at the end of the changing\n   * process.\n   *\n   * @param {Date|Number|String|Object} rangeStart - Start date of the range\n   * or {clear: true} to clear the date\n   * @param {Date|Number|String|Object} rangeEnd - End date of the range\n   * or {clear: true} to clear the date\n   */\n\n\n  setDates(rangeStart, rangeEnd) {\n    const [datepicker0, datepicker1] = this.datepickers;\n    const origDates = this.dates; // If range normalization runs on every change, we can't set a new range\n    // that starts after the end of the current range correctly because the\n    // normalization process swaps start↔︎end right after setting the new start\n    // date. To prevent this, the normalization process needs to run once after\n    // both of the new dates are set.\n\n    this._updating = true;\n    datepicker0.setDate(rangeStart);\n    datepicker1.setDate(rangeEnd);\n    delete this._updating;\n\n    if (datepicker1.dates[0] !== origDates[1]) {\n      onChangeDate(this, {\n        target: this.inputs[1]\n      });\n    } else if (datepicker0.dates[0] !== origDates[0]) {\n      onChangeDate(this, {\n        target: this.inputs[0]\n      });\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/chrismo/Documents/PROJECTS/go-movies/frontend/node_modules/vanillajs-datepicker/js/DateRangePicker.js"],"names":["registerListeners","unregisterListeners","formatDate","Datepicker","filterOptions","options","newOpts","Object","assign","inputs","allowOneSidedRange","maxNumberOfDates","setupDatepicker","rangepicker","changeDateListener","el","onChangeDate","ev","_updating","target","datepicker","undefined","datepickers","setDateOptions","render","changedSide","indexOf","otherSide","changedDate","dates","otherDate","setDate","clear","picker","update","DateRangePicker","constructor","element","Array","isArray","from","querySelectorAll","length","slice","bind","cleanOptions","defineProperty","get","freeze","setOptions","destroy","getDates","format","callback","date","config","locale","Date","map","setDates","rangeStart","rangeEnd","datepicker0","datepicker1","origDates"],"mappings":"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","sourcesContent":["import {registerListeners, unregisterListeners} from './lib/event.js';\nimport {formatDate} from './lib/date-format.js';\nimport Datepicker from './Datepicker.js';\n\n// filter out the config options inapproprite to pass to Datepicker\nfunction filterOptions(options) {\n  const newOpts = Object.assign({}, options);\n\n  delete newOpts.inputs;\n  delete newOpts.allowOneSidedRange;\n  delete newOpts.maxNumberOfDates; // to ensure each datepicker handles a single date\n\n  return newOpts;\n}\n\nfunction setupDatepicker(rangepicker, changeDateListener, el, options) {\n  registerListeners(rangepicker, [\n    [el, 'changeDate', changeDateListener],\n  ]);\n  new Datepicker(el, options, rangepicker);\n}\n\nfunction onChangeDate(rangepicker, ev) {\n  // to prevent both datepickers trigger the other side's update each other\n  if (rangepicker._updating) {\n    return;\n  }\n  rangepicker._updating = true;\n\n  const target = ev.target;\n  if (target.datepicker === undefined) {\n    return;\n  }\n\n  const datepickers = rangepicker.datepickers;\n  const setDateOptions = {render: false};\n  const changedSide = rangepicker.inputs.indexOf(target);\n  const otherSide = changedSide === 0 ? 1 : 0;\n  const changedDate = datepickers[changedSide].dates[0];\n  const otherDate = datepickers[otherSide].dates[0];\n\n  if (changedDate !== undefined && otherDate !== undefined) {\n    // if the start of the range > the end, swap them\n    if (changedSide === 0 && changedDate > otherDate) {\n      datepickers[0].setDate(otherDate, setDateOptions);\n      datepickers[1].setDate(changedDate, setDateOptions);\n    } else if (changedSide === 1 && changedDate < otherDate) {\n      datepickers[0].setDate(changedDate, setDateOptions);\n      datepickers[1].setDate(otherDate, setDateOptions);\n    }\n  } else if (!rangepicker.allowOneSidedRange) {\n    // to prevent the range from becoming one-sided, copy changed side's\n    // selection (no matter if it's empty) to the other side\n    if (changedDate !== undefined || otherDate !== undefined) {\n      setDateOptions.clear = true;\n      datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);\n    }\n  }\n  datepickers[0].picker.update().render();\n  datepickers[1].picker.update().render();\n  delete rangepicker._updating;\n}\n\n/**\n * Class representing a date range picker\n */\nexport default class DateRangePicker  {\n  /**\n   * Create a date range picker\n   * @param  {Element} element - element to bind a date range picker\n   * @param  {Object} [options] - config options\n   */\n  constructor(element, options = {}) {\n    const inputs = Array.isArray(options.inputs)\n      ? options.inputs\n      : Array.from(element.querySelectorAll('input'));\n    if (inputs.length < 2) {\n      return;\n    }\n\n    element.rangepicker = this;\n    this.element = element;\n    this.inputs = inputs.slice(0, 2);\n    this.allowOneSidedRange = !!options.allowOneSidedRange;\n\n    const changeDateListener = onChangeDate.bind(null, this);\n    const cleanOptions = filterOptions(options);\n    // in order for initial date setup to work right when pcicLvel > 0,\n    // let Datepicker constructor add the instance to the rangepicker\n    const datepickers = [];\n    Object.defineProperty(this, 'datepickers', {\n      get() {\n        return datepickers;\n      },\n    });\n    setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);\n    setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);\n    Object.freeze(datepickers);\n    // normalize the range if inital dates are given\n    if (datepickers[0].dates.length > 0) {\n      onChangeDate(this, {target: this.inputs[0]});\n    } else if (datepickers[1].dates.length > 0) {\n      onChangeDate(this, {target: this.inputs[1]});\n    }\n  }\n\n  /**\n   * @type {Array} - selected date of the linked date pickers\n   */\n  get dates() {\n    return this.datepickers.length === 2\n      ? [\n          this.datepickers[0].dates[0],\n          this.datepickers[1].dates[0],\n        ]\n      : undefined;\n  }\n\n  /**\n   * Set new values to the config options\n   * @param {Object} options - config options to update\n   */\n  setOptions(options) {\n    this.allowOneSidedRange = !!options.allowOneSidedRange;\n\n    const cleanOptions = filterOptions(options);\n    this.datepickers[0].setOptions(cleanOptions);\n    this.datepickers[1].setOptions(cleanOptions);\n  }\n\n  /**\n   * Destroy the DateRangePicker instance\n   * @return {DateRangePicker} - the instance destroyed\n   */\n  destroy() {\n    this.datepickers[0].destroy();\n    this.datepickers[1].destroy();\n    unregisterListeners(this);\n    delete this.element.rangepicker;\n  }\n\n  /**\n   * Get the start and end dates of the date range\n   *\n   * The method returns Date objects by default. If format string is passed,\n   * it returns date strings formatted in given format.\n   * The result array always contains 2 items (start date/end date) and\n   * undefined is used for unselected side. (e.g. If none is selected,\n   * the result will be [undefined, undefined]. If only the end date is set\n   * when allowOneSidedRange config option is true, [undefined, endDate] will\n   * be returned.)\n   *\n   * @param  {String} [format] - Format string to stringify the dates\n   * @return {Array} - Start and end dates\n   */\n  getDates(format = undefined) {\n    const callback = format\n      ? date => formatDate(date, format, this.datepickers[0].config.locale)\n      : date => new Date(date);\n\n    return this.dates.map(date => date === undefined ? date : callback(date));\n  }\n\n  /**\n   * Set the start and end dates of the date range\n   *\n   * The method calls datepicker.setDate() internally using each of the\n   * arguments in start→end order.\n   *\n   * When a clear: true option object is passed instead of a date, the method\n   * clears the date.\n   *\n   * If an invalid date, the same date as the current one or an option object\n   * without clear: true is passed, the method considers that argument as an\n   * \"ineffective\" argument because calling datepicker.setDate() with those\n   * values makes no changes to the date selection.\n   *\n   * When the allowOneSidedRange config option is false, passing {clear: true}\n   * to clear the range works only when it is done to the last effective\n   * argument (in other words, passed to rangeEnd or to rangeStart along with\n   * ineffective rangeEnd). This is because when the date range is changed,\n   * it gets normalized based on the last change at the end of the changing\n   * process.\n   *\n   * @param {Date|Number|String|Object} rangeStart - Start date of the range\n   * or {clear: true} to clear the date\n   * @param {Date|Number|String|Object} rangeEnd - End date of the range\n   * or {clear: true} to clear the date\n   */\n  setDates(rangeStart, rangeEnd) {\n    const [datepicker0, datepicker1] = this.datepickers;\n    const origDates = this.dates;\n\n    // If range normalization runs on every change, we can't set a new range\n    // that starts after the end of the current range correctly because the\n    // normalization process swaps start↔︎end right after setting the new start\n    // date. To prevent this, the normalization process needs to run once after\n    // both of the new dates are set.\n    this._updating = true;\n    datepicker0.setDate(rangeStart);\n    datepicker1.setDate(rangeEnd);\n    delete this._updating;\n\n    if (datepicker1.dates[0] !== origDates[1]) {\n      onChangeDate(this, {target: this.inputs[1]});\n    } else if (datepicker0.dates[0] !== origDates[0]) {\n      onChangeDate(this, {target: this.inputs[0]});\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}