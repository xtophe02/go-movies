{"ast":null,"code":"import { stripTime, today } from './date.js';\nimport { lastItemOf } from './utils.js'; // pattern for format parts\n\nexport const reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/; // pattern for non date parts\n\nexport const reNonDateParts = /[\\s!-/:-@[-`{-~年月日]+/; // cache for persed formats\n\nlet knownFormats = {}; // parse funtions for date parts\n\nconst parseFns = {\n  y(date, year) {\n    return new Date(date).setFullYear(parseInt(year, 10));\n  },\n\n  m(date, month, locale) {\n    const newDate = new Date(date);\n    let monthIndex = parseInt(month, 10) - 1;\n\n    if (isNaN(monthIndex)) {\n      if (!month) {\n        return NaN;\n      }\n\n      const monthName = month.toLowerCase();\n\n      const compareNames = name => name.toLowerCase().startsWith(monthName); // compare with both short and full names because some locales have periods\n      // in the short names (not equal to the first X letters of the full names)\n\n\n      monthIndex = locale.monthsShort.findIndex(compareNames);\n\n      if (monthIndex < 0) {\n        monthIndex = locale.months.findIndex(compareNames);\n      }\n\n      if (monthIndex < 0) {\n        return NaN;\n      }\n    }\n\n    newDate.setMonth(monthIndex);\n    return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();\n  },\n\n  d(date, day) {\n    return new Date(date).setDate(parseInt(day, 10));\n  }\n\n}; // format functions for date parts\n\nconst formatFns = {\n  d(date) {\n    return date.getDate();\n  },\n\n  dd(date) {\n    return padZero(date.getDate(), 2);\n  },\n\n  D(date, locale) {\n    return locale.daysShort[date.getDay()];\n  },\n\n  DD(date, locale) {\n    return locale.days[date.getDay()];\n  },\n\n  m(date) {\n    return date.getMonth() + 1;\n  },\n\n  mm(date) {\n    return padZero(date.getMonth() + 1, 2);\n  },\n\n  M(date, locale) {\n    return locale.monthsShort[date.getMonth()];\n  },\n\n  MM(date, locale) {\n    return locale.months[date.getMonth()];\n  },\n\n  y(date) {\n    return date.getFullYear();\n  },\n\n  yy(date) {\n    return padZero(date.getFullYear(), 2).slice(-2);\n  },\n\n  yyyy(date) {\n    return padZero(date.getFullYear(), 4);\n  }\n\n}; // get month index in normal range (0 - 11) from any number\n\nfunction normalizeMonth(monthIndex) {\n  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);\n}\n\nfunction padZero(num, length) {\n  return num.toString().padStart(length, '0');\n}\n\nfunction parseFormatString(format) {\n  if (typeof format !== 'string') {\n    throw new Error(\"Invalid date format.\");\n  }\n\n  if (format in knownFormats) {\n    return knownFormats[format];\n  } // sprit the format string into parts and seprators\n\n\n  const separators = format.split(reFormatTokens);\n  const parts = format.match(new RegExp(reFormatTokens, 'g'));\n\n  if (separators.length === 0 || !parts) {\n    throw new Error(\"Invalid date format.\");\n  } // collect format functions used in the format\n\n\n  const partFormatters = parts.map(token => formatFns[token]); // collect parse function keys used in the format\n  // iterate over parseFns' keys in order to keep the order of the keys.\n\n  const partParserKeys = Object.keys(parseFns).reduce((keys, key) => {\n    const token = parts.find(part => part[0] !== 'D' && part[0].toLowerCase() === key);\n\n    if (token) {\n      keys.push(key);\n    }\n\n    return keys;\n  }, []);\n  return knownFormats[format] = {\n    parser(dateStr, locale) {\n      const dateParts = dateStr.split(reNonDateParts).reduce((dtParts, part, index) => {\n        if (part.length > 0 && parts[index]) {\n          const token = parts[index][0];\n\n          if (token === 'M') {\n            dtParts.m = part;\n          } else if (token !== 'D') {\n            dtParts[token] = part;\n          }\n        }\n\n        return dtParts;\n      }, {}); // iterate over partParserkeys so that the parsing is made in the oder\n      // of year, month and day to prevent the day parser from correcting last\n      // day of month wrongly\n\n      return partParserKeys.reduce((origDate, key) => {\n        const newDate = parseFns[key](origDate, dateParts[key], locale); // ingnore the part failed to parse\n\n        return isNaN(newDate) ? origDate : newDate;\n      }, today());\n    },\n\n    formatter(date, locale) {\n      let dateStr = partFormatters.reduce((str, fn, index) => {\n        return str += `${separators[index]}${fn(date, locale)}`;\n      }, ''); // separators' length is always parts' length + 1,\n\n      return dateStr += lastItemOf(separators);\n    }\n\n  };\n}\n\nexport function parseDate(dateStr, format, locale) {\n  if (dateStr instanceof Date || typeof dateStr === 'number') {\n    const date = stripTime(dateStr);\n    return isNaN(date) ? undefined : date;\n  }\n\n  if (!dateStr) {\n    return undefined;\n  }\n\n  if (dateStr === 'today') {\n    return today();\n  }\n\n  if (format && format.toValue) {\n    const date = format.toValue(dateStr, format, locale);\n    return isNaN(date) ? undefined : stripTime(date);\n  }\n\n  return parseFormatString(format).parser(dateStr, locale);\n}\nexport function formatDate(date, format, locale) {\n  if (isNaN(date) || !date && date !== 0) {\n    return '';\n  }\n\n  const dateObj = typeof date === 'number' ? new Date(date) : date;\n\n  if (format.toDisplay) {\n    return format.toDisplay(dateObj, format, locale);\n  }\n\n  return parseFormatString(format).formatter(dateObj, locale);\n}","map":{"version":3,"sources":["/home/chrismo/Documents/PROJECTS/go-movies/frontend/node_modules/vanillajs-datepicker/js/lib/date-format.js"],"names":["stripTime","today","lastItemOf","reFormatTokens","reNonDateParts","knownFormats","parseFns","y","date","year","Date","setFullYear","parseInt","m","month","locale","newDate","monthIndex","isNaN","NaN","monthName","toLowerCase","compareNames","name","startsWith","monthsShort","findIndex","months","setMonth","getMonth","normalizeMonth","setDate","getTime","d","day","formatFns","getDate","dd","padZero","D","daysShort","getDay","DD","days","mm","M","MM","getFullYear","yy","slice","yyyy","num","length","toString","padStart","parseFormatString","format","Error","separators","split","parts","match","RegExp","partFormatters","map","token","partParserKeys","Object","keys","reduce","key","find","part","push","parser","dateStr","dateParts","dtParts","index","origDate","formatter","str","fn","parseDate","undefined","toValue","formatDate","dateObj","toDisplay"],"mappings":"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","sourcesContent":["import {stripTime, today} from './date.js';\nimport {lastItemOf} from './utils.js';\n\n// pattern for format parts\nexport const reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;\n// pattern for non date parts\nexport const reNonDateParts = /[\\s!-/:-@[-`{-~年月日]+/;\n// cache for persed formats\nlet knownFormats = {};\n// parse funtions for date parts\nconst parseFns = {\n  y(date, year) {\n    return new Date(date).setFullYear(parseInt(year, 10));\n  },\n  m(date, month, locale) {\n    const newDate = new Date(date);\n    let monthIndex = parseInt(month, 10) - 1;\n\n    if (isNaN(monthIndex)) {\n      if (!month) {\n        return NaN;\n      }\n\n      const monthName = month.toLowerCase();\n      const compareNames = name => name.toLowerCase().startsWith(monthName);\n      // compare with both short and full names because some locales have periods\n      // in the short names (not equal to the first X letters of the full names)\n      monthIndex = locale.monthsShort.findIndex(compareNames);\n      if (monthIndex < 0) {\n        monthIndex = locale.months.findIndex(compareNames);\n      }\n      if (monthIndex < 0) {\n        return NaN;\n      }\n    }\n\n    newDate.setMonth(monthIndex);\n    return newDate.getMonth() !== normalizeMonth(monthIndex)\n      ? newDate.setDate(0)\n      : newDate.getTime();\n  },\n  d(date, day) {\n    return new Date(date).setDate(parseInt(day, 10));\n  },\n};\n// format functions for date parts\nconst formatFns = {\n  d(date) {\n    return date.getDate();\n  },\n  dd(date) {\n    return padZero(date.getDate(), 2);\n  },\n  D(date, locale) {\n    return locale.daysShort[date.getDay()];\n  },\n  DD(date, locale) {\n    return locale.days[date.getDay()];\n  },\n  m(date) {\n    return date.getMonth() + 1;\n  },\n  mm(date) {\n    return padZero(date.getMonth() + 1, 2);\n  },\n  M(date, locale) {\n    return locale.monthsShort[date.getMonth()];\n  },\n  MM(date, locale) {\n    return locale.months[date.getMonth()];\n  },\n  y(date) {\n    return date.getFullYear();\n  },\n  yy(date) {\n    return padZero(date.getFullYear(), 2).slice(-2);\n  },\n  yyyy(date) {\n    return padZero(date.getFullYear(), 4);\n  },\n};\n\n// get month index in normal range (0 - 11) from any number\nfunction normalizeMonth(monthIndex) {\n  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);\n}\n\nfunction padZero(num, length) {\n  return num.toString().padStart(length, '0');\n}\n\nfunction parseFormatString(format) {\n  if (typeof format !== 'string') {\n    throw new Error(\"Invalid date format.\");\n  }\n  if (format in knownFormats) {\n    return knownFormats[format];\n  }\n\n  // sprit the format string into parts and seprators\n  const separators = format.split(reFormatTokens);\n  const parts = format.match(new RegExp(reFormatTokens, 'g'));\n  if (separators.length === 0 || !parts) {\n    throw new Error(\"Invalid date format.\");\n  }\n\n  // collect format functions used in the format\n  const partFormatters = parts.map(token => formatFns[token]);\n\n  // collect parse function keys used in the format\n  // iterate over parseFns' keys in order to keep the order of the keys.\n  const partParserKeys = Object.keys(parseFns).reduce((keys, key) => {\n    const token = parts.find(part => part[0] !== 'D' && part[0].toLowerCase() === key);\n    if (token) {\n      keys.push(key);\n    }\n    return keys;\n  }, []);\n\n  return knownFormats[format] = {\n    parser(dateStr, locale) {\n      const dateParts = dateStr.split(reNonDateParts).reduce((dtParts, part, index) => {\n        if (part.length > 0 && parts[index]) {\n          const token = parts[index][0];\n          if (token === 'M') {\n            dtParts.m = part;\n          } else if (token !== 'D') {\n            dtParts[token] = part;\n          }\n        }\n        return dtParts;\n      }, {});\n\n      // iterate over partParserkeys so that the parsing is made in the oder\n      // of year, month and day to prevent the day parser from correcting last\n      // day of month wrongly\n      return partParserKeys.reduce((origDate, key) => {\n        const newDate = parseFns[key](origDate, dateParts[key], locale);\n        // ingnore the part failed to parse\n        return isNaN(newDate) ? origDate : newDate;\n      }, today());\n    },\n    formatter(date, locale) {\n      let dateStr = partFormatters.reduce((str, fn, index) => {\n        return str += `${separators[index]}${fn(date, locale)}`;\n      }, '');\n      // separators' length is always parts' length + 1,\n      return dateStr += lastItemOf(separators);\n    },\n  };\n}\n\nexport function parseDate(dateStr, format, locale) {\n  if (dateStr instanceof Date || typeof dateStr === 'number') {\n    const date = stripTime(dateStr);\n    return isNaN(date) ? undefined : date;\n  }\n  if (!dateStr) {\n    return undefined;\n  }\n  if (dateStr === 'today') {\n    return today();\n  }\n\n  if (format && format.toValue) {\n    const date = format.toValue(dateStr, format, locale);\n    return isNaN(date) ? undefined : stripTime(date);\n  }\n\n  return parseFormatString(format).parser(dateStr, locale);\n}\n\nexport function formatDate(date, format, locale) {\n  if (isNaN(date) || (!date && date !== 0)) {\n    return '';\n  }\n\n  const dateObj = typeof date === 'number' ? new Date(date) : date;\n\n  if (format.toDisplay) {\n    return format.toDisplay(dateObj, format, locale);\n  }\n\n  return parseFormatString(format).formatter(dateObj, locale);\n}\n"]},"metadata":{},"sourceType":"module"}