{"ast":null,"code":"import EventEmitter from './events';\nimport { optionsFromDataset, querySelectorAll, querySelector } from './dom';\nimport uuid from './uuid';\nexport default class Component extends EventEmitter {\n  constructor(element) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let defaultOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.element = querySelector(element, document); // An invalid selector or non-DOM node has been provided.\n\n    if (!this.element) {\n      throw new Error(`An invalid selector or non-DOM node has been provided for ${this.constructor.name}.`);\n    }\n\n    this.element[this.constructor.name] = this.constructor._interface.bind(this);\n    this.element[this.constructor.name].Constructor = this.constructor.name;\n    this.id = uuid(this.constructor.name + '-');\n    this.options = { ...defaultOptions,\n      ...options,\n      ...optionsFromDataset(this.element, defaultOptions) // Use Element dataset values to override options\n\n    };\n  }\n  /**\n   * Initiate all DOM element corresponding to selector\n   * @method\n   * @return {Array} Array of all Plugin instances\n   */\n\n\n  static attach() {\n    let selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let node = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let instances = new Array();\n\n    if (selector !== null) {\n      querySelectorAll(selector, node).forEach(element => {\n        // Check if plugin has already been instantiated for element\n        if (typeof element[this.name] === 'undefined') {\n          // If no then instantiate it and register it in element\n          instances.push(new this(element, {\n            selector: selector,\n            ...options\n          }));\n        } else {\n          // If Yes then return the existing instance\n          instances.push(element[this.name]);\n        }\n      });\n\n      if (typeof window[this.name] === 'undefined') {\n        window[this.name] = {\n          'observers': []\n        };\n      }\n\n      if (window[this.name]['observers'] && !window[this.name]['observers'].includes(selector)) {\n        this.observeDom(selector, options);\n        window[this.name]['observers'].push(selector);\n      }\n    }\n\n    return instances;\n  }\n  /**\n   * Observe DOM mutations to automatically initialize plugin on new elements when added to the DOM\n   * \n   * @param {string} selector \n   * @param {Object} options \n   */\n\n\n  static observeDom(selector, options) {\n    const observer = new MutationObserver(mutations => {\n      mutations.forEach(mutation => {\n        for (let i = 0; i < mutation.addedNodes.length; i++) {\n          if (typeof window[this.name] !== 'undefined') {\n            this.attach(selector, options, mutation.addedNodes[i]);\n          }\n        }\n      });\n    });\n\n    if (typeof document !== 'undefined') {\n      observer.observe(document, {\n        childList: true,\n        subtree: true\n      });\n    }\n  }\n\n  static _interface() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof name === 'string') {\n      if (typeof this[name] === 'undefined') {\n        throw new TypeError(`No method named \"${name}\"`);\n      }\n\n      return this[name](options);\n    }\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["/home/chrismo/Documents/PROJECTS/go-movies/frontend/node_modules/@creativebulma/bulma-tagsinput/src/js/utils/component.js"],"names":["EventEmitter","optionsFromDataset","querySelectorAll","querySelector","uuid","Component","constructor","element","options","defaultOptions","document","Error","name","_interface","bind","Constructor","id","attach","selector","node","instances","Array","forEach","push","window","includes","observeDom","observer","MutationObserver","mutations","mutation","i","addedNodes","length","observe","childList","subtree","TypeError"],"mappings":"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","sourcesContent":["import EventEmitter from './events';\nimport { optionsFromDataset, querySelectorAll, querySelector } from './dom';\nimport uuid from './uuid';\n\nexport default class Component extends EventEmitter {\n\tconstructor(element, options = {}, defaultOptions = {}) {\n\t\tsuper();\n\n\t\tthis.element = querySelector(element, document);\n\n\t\t// An invalid selector or non-DOM node has been provided.\n\t\tif (!this.element) {\n\t\t\tthrow new Error(`An invalid selector or non-DOM node has been provided for ${this.constructor.name}.`);\n\t\t}\n\n\t\tthis.element[this.constructor.name] = this.constructor._interface.bind(this);\n\t\tthis.element[this.constructor.name].Constructor = this.constructor.name;\n\t\tthis.id = uuid(this.constructor.name + '-');\n\n\t\tthis.options = {\n\t\t\t...defaultOptions,\n\t\t\t...options,\n\t\t\t...optionsFromDataset(this.element, defaultOptions) // Use Element dataset values to override options\n\t\t};\n\t}\n\n\t/**\n\t * Initiate all DOM element corresponding to selector\n\t * @method\n\t * @return {Array} Array of all Plugin instances\n\t */\n\tstatic attach(selector = null, options = {}, node = null) {\n\t\tlet instances = new Array();\n\n\t\tif (selector !== null) {\n\t\t\tquerySelectorAll(selector, node).forEach(element => {\n\t\t\t\t// Check if plugin has already been instantiated for element\n\t\t\t\tif (typeof element[this.name] === 'undefined') { // If no then instantiate it and register it in element\n\t\t\t\t\tinstances.push(new this(element, {\n\t\t\t\t\t\tselector: selector,\n\t\t\t\t\t\t...options\n\t\t\t\t\t}));\n\t\t\t\t} else { // If Yes then return the existing instance\n\t\t\t\t\tinstances.push(element[this.name]);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (typeof window[this.name] === 'undefined') {\n\t\t\t\twindow[this.name] = {\n\t\t\t\t\t'observers': []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (window[this.name]['observers'] && !window[this.name]['observers'].includes(selector)) {\n\t\t\t\tthis.observeDom(selector, options);\n\n\t\t\t\twindow[this.name]['observers'].push(selector);\n\t\t\t}\n\t\t}\n\n\t\treturn instances;\n\t}\n\n\t/**\n\t * Observe DOM mutations to automatically initialize plugin on new elements when added to the DOM\n\t * \n\t * @param {string} selector \n\t * @param {Object} options \n\t */\n\tstatic observeDom(selector, options) {\n\t\tconst observer = new MutationObserver(mutations => {\n\t\t\tmutations.forEach(mutation => {\n\t\t\t\tfor (let i = 0; i < mutation.addedNodes.length; i++) {\n\t\t\t\t\tif (typeof window[this.name] !== 'undefined') {\n\t\t\t\t\t\tthis.attach(selector, options, mutation.addedNodes[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tif (typeof document !== 'undefined') {\n\t\t\tobserver.observe(document, {\n\t\t\t\tchildList: true,\n\t\t\t\tsubtree: true\n\t\t\t});\n\t\t}\n\t}\n\n\tstatic _interface(name = null, options = {}) {\n\t\tif (typeof name === 'string') {\n\t\t\tif (typeof this[name] === 'undefined') {\n\t\t\t\tthrow new TypeError(`No method named \"${name}\"`);\n\t\t\t}\n\n\t\t\treturn this[name](options);\n\t\t}\n\n\t\treturn this;\n\t}\n}"]},"metadata":{},"sourceType":"module"}