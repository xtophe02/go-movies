{"ast":null,"code":"import { lastItemOf, stringToArray, isInRange } from './lib/utils.js';\nimport { today, regularizeDate } from './lib/date.js';\nimport { parseDate, formatDate } from './lib/date-format.js';\nimport { isActiveElement } from './lib/dom.js';\nimport { registerListeners, unregisterListeners } from './lib/event.js';\nimport { locales } from './i18n/base-locales.js';\nimport defaultOptions from './options/defaultOptions.js';\nimport processOptions from './options/processOptions.js';\nimport Picker from './picker/Picker.js';\nimport { triggerDatepickerEvent } from './events/functions.js';\nimport { onKeydown, onFocus, onMousedown, onClickInput, onPaste } from './events/inputFieldListeners.js';\nimport { onClickOutside } from './events/otherListeners.js';\n\nfunction stringifyDates(dates, config) {\n  return dates.map(dt => formatDate(dt, config.format, config.locale)).join(config.dateDelimiter);\n} // parse input dates and create an array of time values for selection\n// returns undefined if there are no valid dates in inputDates\n// when origDates (current selection) is passed, the function works to mix\n// the input dates into the current selection\n\n\nfunction processInputDates(datepicker, inputDates) {\n  let clear = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // const {config, dates: origDates, rangepicker} = datepicker;\n  const {\n    config,\n    dates: origDates,\n    rangeSideIndex\n  } = datepicker;\n\n  if (inputDates.length === 0) {\n    // empty input is considered valid unless origiDates is passed\n    return clear ? [] : undefined;\n  } // const rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];\n\n\n  let newDates = inputDates.reduce((dates, dt) => {\n    let date = parseDate(dt, config.format, config.locale);\n\n    if (date === undefined) {\n      return dates;\n    } // adjust to 1st of the month/Jan 1st of the year\n    // or to the last day of the monh/Dec 31st of the year if the datepicker\n    // is the range-end picker of a rangepicker\n\n\n    date = regularizeDate(date, config.pickLevel, rangeSideIndex);\n\n    if (isInRange(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.datesDisabled.includes(date) && (config.pickLevel > 0 || !config.daysOfWeekDisabled.includes(new Date(date).getDay()))) {\n      dates.push(date);\n    }\n\n    return dates;\n  }, []);\n\n  if (newDates.length === 0) {\n    return;\n  }\n\n  if (config.multidate && !clear) {\n    // get the synmetric difference between origDates and newDates\n    newDates = newDates.reduce((dates, date) => {\n      if (!origDates.includes(date)) {\n        dates.push(date);\n      }\n\n      return dates;\n    }, origDates.filter(date => !newDates.includes(date)));\n  } // do length check always because user can input multiple dates regardless of the mode\n\n\n  return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates ? newDates.slice(config.maxNumberOfDates * -1) : newDates;\n} // refresh the UI elements\n// modes: 1: input only, 2, picker only, 3 both\n\n\nfunction refreshUI(datepicker) {\n  let mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  let quickRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const {\n    config,\n    picker,\n    inputField\n  } = datepicker;\n\n  if (mode & 2) {\n    const newView = picker.active ? config.pickLevel : config.startView;\n    picker.update().changeView(newView).render(quickRender);\n  }\n\n  if (mode & 1 && inputField) {\n    inputField.value = stringifyDates(datepicker.dates, config);\n  }\n}\n\nfunction setDate(datepicker, inputDates, options) {\n  let {\n    clear,\n    render,\n    autohide,\n    revert\n  } = options;\n\n  if (render === undefined) {\n    render = true;\n  }\n\n  if (!render) {\n    autohide = false;\n  } else if (autohide === undefined) {\n    autohide = datepicker.config.autohide;\n  }\n\n  const newDates = processInputDates(datepicker, inputDates, clear);\n\n  if (!newDates && !revert) {\n    return;\n  }\n\n  if (newDates && newDates.toString() !== datepicker.dates.toString()) {\n    datepicker.dates = newDates;\n    refreshUI(datepicker, render ? 3 : 1);\n    triggerDatepickerEvent(datepicker, 'changeDate');\n  } else {\n    refreshUI(datepicker, 1);\n  }\n\n  if (autohide) {\n    datepicker.hide();\n  }\n}\n/**\n * Class representing a date picker\n */\n\n\nexport default class Datepicker {\n  /**\n   * Create a date picker\n   * @param  {Element} element - element to bind a date picker\n   * @param  {Object} [options] - config options\n   * @param  {DateRangePicker} [rangepicker] - DateRangePicker instance the\n   * date picker belongs to. Use this only when creating date picker as a part\n   * of date range picker\n   */\n  constructor(element) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let rangepicker = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    element.datepicker = this;\n    this.element = element;\n    const config = this.config = Object.assign({\n      buttonClass: options.buttonClass && String(options.buttonClass) || 'button',\n      container: null,\n      defaultViewDate: today(),\n      maxDate: undefined,\n      minDate: undefined\n    }, processOptions(defaultOptions, this)); // configure by type\n\n    const inline = this.inline = element.tagName !== 'INPUT';\n    let inputField;\n\n    if (inline) {\n      config.container = element;\n    } else {\n      if (options.container) {\n        // omit string type check because it doesn't guarantee to avoid errors\n        // (invalid selector string causes abend with sytax error)\n        config.container = options.container instanceof HTMLElement ? options.container : document.querySelector(options.container);\n      }\n\n      inputField = this.inputField = element;\n      inputField.classList.add('datepicker-input');\n    }\n\n    if (rangepicker) {\n      // check validiry\n      const index = rangepicker.inputs.indexOf(inputField);\n      const datepickers = rangepicker.datepickers;\n\n      if (index < 0 || index > 1 || !Array.isArray(datepickers)) {\n        throw Error('Invalid rangepicker object.');\n      } // attach itaelf to the rangepicker here so that processInputDates() can\n      // determine if this is the range-end picker of the rangepicker while\n      // setting inital values when pickLevel > 0\n\n\n      datepickers[index] = this; // add getter for rangepicker\n\n      Object.defineProperty(this, 'rangepicker', {\n        get() {\n          return rangepicker;\n        }\n\n      });\n      Object.defineProperty(this, 'rangeSideIndex', {\n        get() {\n          return index;\n        }\n\n      });\n    } // set up config\n\n\n    this._options = options;\n    Object.assign(config, processOptions(options, this)); // set initial dates\n\n    let initialDates;\n\n    if (inline) {\n      initialDates = stringToArray(element.dataset.date, config.dateDelimiter);\n      delete element.dataset.date;\n    } else {\n      initialDates = stringToArray(inputField.value, config.dateDelimiter);\n    }\n\n    this.dates = []; // process initial value\n\n    const inputDateValues = processInputDates(this, initialDates);\n\n    if (inputDateValues && inputDateValues.length > 0) {\n      this.dates = inputDateValues;\n    }\n\n    if (inputField) {\n      inputField.value = stringifyDates(this.dates, config);\n    }\n\n    const picker = this.picker = new Picker(this);\n\n    if (inline) {\n      this.show();\n    } else {\n      // set up event listeners in other modes\n      const onMousedownDocument = onClickOutside.bind(null, this);\n      const listeners = [[inputField, 'keydown', onKeydown.bind(null, this)], [inputField, 'focus', onFocus.bind(null, this)], [inputField, 'mousedown', onMousedown.bind(null, this)], [inputField, 'click', onClickInput.bind(null, this)], [inputField, 'paste', onPaste.bind(null, this)], [document, 'mousedown', onMousedownDocument], [document, 'touchstart', onMousedownDocument], [window, 'resize', picker.place.bind(picker)]];\n      registerListeners(this, listeners);\n    }\n  }\n  /**\n   * Format Date object or time value in given format and language\n   * @param  {Date|Number} date - date or time value to format\n   * @param  {String|Object} format - format string or object that contains\n   * toDisplay() custom formatter, whose signature is\n   * - args:\n   *   - date: {Date} - Date instance of the date passed to the method\n   *   - format: {Object} - the format object passed to the method\n   *   - locale: {Object} - locale for the language specified by `lang`\n   * - return:\n   *     {String} formatted date\n   * @param  {String} [lang=en] - language code for the locale to use\n   * @return {String} formatted date\n   */\n\n\n  static formatDate(date, format, lang) {\n    return formatDate(date, format, lang && locales[lang] || locales.en);\n  }\n  /**\n   * Parse date string\n   * @param  {String|Date|Number} dateStr - date string, Date object or time\n   * value to parse\n   * @param  {String|Object} format - format string or object that contains\n   * toValue() custom parser, whose signature is\n   * - args:\n   *   - dateStr: {String|Date|Number} - the dateStr passed to the method\n   *   - format: {Object} - the format object passed to the method\n   *   - locale: {Object} - locale for the language specified by `lang`\n   * - return:\n   *     {Date|Number} parsed date or its time value\n   * @param  {String} [lang=en] - language code for the locale to use\n   * @return {Number} time value of parsed date\n   */\n\n\n  static parseDate(dateStr, format, lang) {\n    return parseDate(dateStr, format, lang && locales[lang] || locales.en);\n  }\n  /**\n   * @type {Object} - Installed locales in `[languageCode]: localeObject` format\n   * en`:_English (US)_ is pre-installed.\n   */\n\n\n  static get locales() {\n    return locales;\n  }\n  /**\n   * @type {Boolean} - Whether the picker element is shown. `true` whne shown\n   */\n\n\n  get active() {\n    return !!(this.picker && this.picker.active);\n  }\n  /**\n   * @type {HTMLDivElement} - DOM object of picker element\n   */\n\n\n  get pickerElement() {\n    return this.picker ? this.picker.element : undefined;\n  }\n  /**\n   * Set new values to the config options\n   * @param {Object} options - config options to update\n   */\n\n\n  setOptions(options) {\n    const picker = this.picker;\n    const newOptions = processOptions(options, this);\n    Object.assign(this._options, options);\n    Object.assign(this.config, newOptions);\n    picker.setOptions(newOptions);\n    refreshUI(this, 3);\n  }\n  /**\n   * Show the picker element\n   */\n\n\n  show() {\n    if (this.inputField) {\n      if (this.inputField.disabled) {\n        return;\n      }\n\n      if (!isActiveElement(this.inputField) && !this.config.disableTouchKeyboard) {\n        this._showing = true;\n        this.inputField.focus();\n        delete this._showing;\n      }\n    }\n\n    this.picker.show();\n  }\n  /**\n   * Hide the picker element\n   * Not available on inline picker\n   */\n\n\n  hide() {\n    if (this.inline) {\n      return;\n    }\n\n    this.picker.hide();\n    this.picker.update().changeView(this.config.startView).render();\n  }\n  /**\n   * Destroy the Datepicker instance\n   * @return {Detepicker} - the instance destroyed\n   */\n\n\n  destroy() {\n    this.hide();\n    unregisterListeners(this);\n    this.picker.detach();\n\n    if (!this.inline) {\n      this.inputField.classList.remove('datepicker-input');\n    }\n\n    delete this.element.datepicker;\n    return this;\n  }\n  /**\n   * Get the selected date(s)\n   *\n   * The method returns a Date object of selected date by default, and returns\n   * an array of selected dates in multidate mode. If format string is passed,\n   * it returns date string(s) formatted in given format.\n   *\n   * @param  {String} [format] - Format string to stringify the date(s)\n   * @return {Date|String|Date[]|String[]} - selected date(s), or if none is\n   * selected, empty array in multidate mode and untitled in sigledate mode\n   */\n\n\n  getDate() {\n    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    const callback = format ? date => formatDate(date, format, this.config.locale) : date => new Date(date);\n\n    if (this.config.multidate) {\n      return this.dates.map(callback);\n    }\n\n    if (this.dates.length > 0) {\n      return callback(this.dates[0]);\n    }\n  }\n  /**\n   * Set selected date(s)\n   *\n   * In multidate mode, you can pass multiple dates as a series of arguments\n   * or an array. (Since each date is parsed individually, the type of the\n   * dates doesn't have to be the same.)\n   * The given dates are used to toggle the select status of each date. The\n   * number of selected dates is kept from exceeding the length set to\n   * maxNumberOfDates.\n   *\n   * With clear: true option, the method can be used to clear the selection\n   * and to replace the selection instead of toggling in multidate mode.\n   * If the option is passed with no date arguments or an empty dates array,\n   * it works as \"clear\" (clear the selection then set nothing), and if the\n   * option is passed with new dates to select, it works as \"replace\" (clear\n   * the selection then set the given dates)\n   *\n   * When render: false option is used, the method omits re-rendering the\n   * picker element. In this case, you need to call refresh() method later in\n   * order for the picker element to reflect the changes. The input field is\n   * refreshed always regardless of this option.\n   *\n   * When invalid (unparsable, repeated, disabled or out-of-range) dates are\n   * passed, the method ignores them and applies only valid ones. In the case\n   * that all the given dates are invalid, which is distinguished from passing\n   * no dates, the method considers it as an error and leaves the selection\n   * untouched. (The input field also remains untouched unless revert: true\n   * option is used.)\n   *\n   * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date\n   * objects, time values or mix of those for new selection\n   * @param {Object} [options] - function options\n   * - clear: {boolean} - Whether to clear the existing selection\n   *     defualt: false\n   * - render: {boolean} - Whether to re-render the picker element\n   *     default: true\n   * - autohide: {boolean} - Whether to hide the picker element after re-render\n   *     Ignored when used with render: false\n   *     default: config.autohide\n   * - revert: {boolean} - Whether to refresh the input field when all the\n   *     passed dates are invalid\n   *     default: false\n   */\n\n\n  setDate() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    const dates = [...args];\n    const opts = {};\n    const lastArg = lastItemOf(args);\n\n    if (typeof lastArg === 'object' && !Array.isArray(lastArg) && !(lastArg instanceof Date) && lastArg) {\n      Object.assign(opts, dates.pop());\n    }\n\n    const inputDates = Array.isArray(dates[0]) ? dates[0] : dates;\n    setDate(this, inputDates, opts);\n  }\n  /**\n   * Update the selected date(s) with input field's value\n   * Not available on inline picker\n   *\n   * The input field will be refreshed with properly formatted date string.\n   *\n   * In the case that all the entered dates are invalid (unparsable, repeated,\n   * disabled or out-of-range), whixh is distinguished from empty input field,\n   * the method leaves the input field untouched as well as the selection by\n   * default. If revert: true option is used in this case, the input field is\n   * refreshed with the existing selection.\n   *\n   * @param  {Object} [options] - function options\n   * - autohide: {boolean} - whether to hide the picker element after refresh\n   *     default: false\n   * - revert: {boolean} - Whether to refresh the input field when all the\n   *     passed dates are invalid\n   *     default: false\n   */\n\n\n  update() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n    if (this.inline) {\n      return;\n    }\n\n    const opts = Object.assign(options || {}, {\n      clear: true,\n      render: true\n    });\n    const inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);\n    setDate(this, inputDates, opts);\n  }\n  /**\n   * Refresh the picker element and the associated input field\n   * @param {String} [target] - target item when refreshing one item only\n   * 'picker' or 'input'\n   * @param {Boolean} [forceRender] - whether to re-render the picker element\n   * regardless of its state instead of optimized refresh\n   */\n\n\n  refresh() {\n    let target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (target && typeof target !== 'string') {\n      forceRender = target;\n      target = undefined;\n    }\n\n    let mode;\n\n    if (target === 'picker') {\n      mode = 2;\n    } else if (target === 'input') {\n      mode = 1;\n    } else {\n      mode = 3;\n    }\n\n    refreshUI(this, mode, !forceRender);\n  }\n  /**\n   * Enter edit mode\n   * Not available on inline picker or when the picker element is hidden\n   */\n\n\n  enterEditMode() {\n    if (this.inline || !this.picker.active || this.editMode) {\n      return;\n    }\n\n    this.editMode = true;\n    this.inputField.classList.add('in-edit');\n  }\n  /**\n   * Exit from edit mode\n   * Not available on inline picker\n   * @param  {Object} [options] - function options\n   * - update: {boolean} - whether to call update() after exiting\n   *     If false, input field is revert to the existing selection\n   *     default: false\n   */\n\n\n  exitEditMode() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n    if (this.inline || !this.editMode) {\n      return;\n    }\n\n    const opts = Object.assign({\n      update: false\n    }, options);\n    delete this.editMode;\n    this.inputField.classList.remove('in-edit');\n\n    if (opts.update) {\n      this.update(opts);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/chrismo/Documents/PROJECTS/go-movies/frontend/node_modules/vanillajs-datepicker/js/Datepicker.js"],"names":["lastItemOf","stringToArray","isInRange","today","regularizeDate","parseDate","formatDate","isActiveElement","registerListeners","unregisterListeners","locales","defaultOptions","processOptions","Picker","triggerDatepickerEvent","onKeydown","onFocus","onMousedown","onClickInput","onPaste","onClickOutside","stringifyDates","dates","config","map","dt","format","locale","join","dateDelimiter","processInputDates","datepicker","inputDates","clear","origDates","rangeSideIndex","length","undefined","newDates","reduce","date","pickLevel","minDate","maxDate","includes","datesDisabled","daysOfWeekDisabled","Date","getDay","push","multidate","filter","maxNumberOfDates","slice","refreshUI","mode","quickRender","picker","inputField","newView","active","startView","update","changeView","render","value","setDate","options","autohide","revert","toString","hide","Datepicker","constructor","element","rangepicker","Object","assign","buttonClass","String","container","defaultViewDate","inline","tagName","HTMLElement","document","querySelector","classList","add","index","inputs","indexOf","datepickers","Array","isArray","Error","defineProperty","get","_options","initialDates","dataset","inputDateValues","show","onMousedownDocument","bind","listeners","window","place","lang","en","dateStr","pickerElement","setOptions","newOptions","disabled","disableTouchKeyboard","_showing","focus","destroy","detach","remove","getDate","callback","args","opts","lastArg","pop","refresh","target","forceRender","enterEditMode","editMode","exitEditMode"],"mappings":"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","sourcesContent":["import {lastItemOf, stringToArray, isInRange} from './lib/utils.js';\nimport {today, regularizeDate} from './lib/date.js';\nimport {parseDate, formatDate} from './lib/date-format.js';\nimport {isActiveElement} from './lib/dom.js';\nimport {registerListeners, unregisterListeners} from './lib/event.js';\nimport {locales} from './i18n/base-locales.js';\nimport defaultOptions from './options/defaultOptions.js';\nimport processOptions from './options/processOptions.js';\nimport Picker from './picker/Picker.js';\nimport {triggerDatepickerEvent} from './events/functions.js';\nimport {onKeydown, onFocus, onMousedown, onClickInput, onPaste} from './events/inputFieldListeners.js';\nimport {onClickOutside} from './events/otherListeners.js';\n\nfunction stringifyDates(dates, config) {\n  return dates\n    .map(dt => formatDate(dt, config.format, config.locale))\n    .join(config.dateDelimiter);\n}\n\n// parse input dates and create an array of time values for selection\n// returns undefined if there are no valid dates in inputDates\n// when origDates (current selection) is passed, the function works to mix\n// the input dates into the current selection\nfunction processInputDates(datepicker, inputDates, clear = false) {\n  // const {config, dates: origDates, rangepicker} = datepicker;\n  const {config, dates: origDates, rangeSideIndex} = datepicker;\n  if (inputDates.length === 0) {\n    // empty input is considered valid unless origiDates is passed\n    return clear ? [] : undefined;\n  }\n\n  // const rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];\n  let newDates = inputDates.reduce((dates, dt) => {\n    let date = parseDate(dt, config.format, config.locale);\n    if (date === undefined) {\n      return dates;\n    }\n    // adjust to 1st of the month/Jan 1st of the year\n    // or to the last day of the monh/Dec 31st of the year if the datepicker\n    // is the range-end picker of a rangepicker\n    date = regularizeDate(date, config.pickLevel, rangeSideIndex);\n    if (\n      isInRange(date, config.minDate, config.maxDate)\n      && !dates.includes(date)\n      && !config.datesDisabled.includes(date)\n      && (config.pickLevel > 0 || !config.daysOfWeekDisabled.includes(new Date(date).getDay()))\n    ) {\n      dates.push(date);\n    }\n    return dates;\n  }, []);\n  if (newDates.length === 0) {\n    return;\n  }\n  if (config.multidate && !clear) {\n    // get the synmetric difference between origDates and newDates\n    newDates = newDates.reduce((dates, date) => {\n      if (!origDates.includes(date)) {\n        dates.push(date);\n      }\n      return dates;\n    }, origDates.filter(date => !newDates.includes(date)));\n  }\n  // do length check always because user can input multiple dates regardless of the mode\n  return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates\n    ? newDates.slice(config.maxNumberOfDates * -1)\n    : newDates;\n}\n\n// refresh the UI elements\n// modes: 1: input only, 2, picker only, 3 both\nfunction refreshUI(datepicker, mode = 3, quickRender = true) {\n  const {config, picker, inputField} = datepicker;\n  if (mode & 2) {\n    const newView = picker.active ? config.pickLevel : config.startView;\n    picker.update().changeView(newView).render(quickRender);\n  }\n  if (mode & 1 && inputField) {\n    inputField.value = stringifyDates(datepicker.dates, config);\n  }\n}\n\nfunction setDate(datepicker, inputDates, options) {\n  let {clear, render, autohide, revert} = options;\n  if (render === undefined) {\n    render = true;\n  }\n  if (!render) {\n    autohide = false;\n  } else if (autohide === undefined) {\n    autohide = datepicker.config.autohide;\n  }\n\n  const newDates = processInputDates(datepicker, inputDates, clear);\n  if (!newDates && !revert) {\n    return;\n  }\n  if (newDates && newDates.toString() !== datepicker.dates.toString()) {\n    datepicker.dates = newDates;\n    refreshUI(datepicker, render ? 3 : 1);\n    triggerDatepickerEvent(datepicker, 'changeDate');\n  } else {\n    refreshUI(datepicker, 1);\n  }\n\n  if (autohide) {\n    datepicker.hide();\n  }\n}\n\n/**\n * Class representing a date picker\n */\nexport default class Datepicker {\n  /**\n   * Create a date picker\n   * @param  {Element} element - element to bind a date picker\n   * @param  {Object} [options] - config options\n   * @param  {DateRangePicker} [rangepicker] - DateRangePicker instance the\n   * date picker belongs to. Use this only when creating date picker as a part\n   * of date range picker\n   */\n  constructor(element, options = {}, rangepicker = undefined) {\n    element.datepicker = this;\n    this.element = element;\n\n    const config = this.config = Object.assign({\n      buttonClass: (options.buttonClass && String(options.buttonClass)) || 'button',\n      container: null,\n      defaultViewDate: today(),\n      maxDate: undefined,\n      minDate: undefined,\n    }, processOptions(defaultOptions, this));\n    // configure by type\n    const inline = this.inline = element.tagName !== 'INPUT';\n    let inputField;\n    if (inline) {\n      config.container = element;\n    } else {\n      if (options.container) {\n        // omit string type check because it doesn't guarantee to avoid errors\n        // (invalid selector string causes abend with sytax error)\n        config.container = options.container instanceof HTMLElement\n          ? options.container\n          : document.querySelector(options.container);\n      }\n      inputField = this.inputField = element;\n      inputField.classList.add('datepicker-input');\n    }\n    if (rangepicker) {\n      // check validiry\n      const index = rangepicker.inputs.indexOf(inputField);\n      const datepickers = rangepicker.datepickers;\n      if (index < 0 || index > 1 || !Array.isArray(datepickers)) {\n        throw Error('Invalid rangepicker object.');\n      }\n      // attach itaelf to the rangepicker here so that processInputDates() can\n      // determine if this is the range-end picker of the rangepicker while\n      // setting inital values when pickLevel > 0\n      datepickers[index] = this;\n      // add getter for rangepicker\n      Object.defineProperty(this, 'rangepicker', {\n        get() {\n          return rangepicker;\n        },\n      });\n      Object.defineProperty(this, 'rangeSideIndex', {\n        get() {\n          return index;\n        },\n      });\n    }\n\n    // set up config\n    this._options = options;\n    Object.assign(config, processOptions(options, this));\n\n    // set initial dates\n    let initialDates;\n    if (inline) {\n      initialDates = stringToArray(element.dataset.date, config.dateDelimiter);\n      delete element.dataset.date;\n    } else {\n      initialDates = stringToArray(inputField.value, config.dateDelimiter);\n    }\n    this.dates = [];\n    // process initial value\n    const inputDateValues = processInputDates(this, initialDates);\n    if (inputDateValues && inputDateValues.length > 0) {\n      this.dates = inputDateValues;\n    }\n    if (inputField) {\n      inputField.value = stringifyDates(this.dates, config);\n    }\n\n    const picker = this.picker = new Picker(this);\n\n    if (inline) {\n      this.show();\n    } else {\n      // set up event listeners in other modes\n      const onMousedownDocument = onClickOutside.bind(null, this);\n      const listeners = [\n        [inputField, 'keydown', onKeydown.bind(null, this)],\n        [inputField, 'focus', onFocus.bind(null, this)],\n        [inputField, 'mousedown', onMousedown.bind(null, this)],\n        [inputField, 'click', onClickInput.bind(null, this)],\n        [inputField, 'paste', onPaste.bind(null, this)],\n        [document, 'mousedown', onMousedownDocument],\n        [document, 'touchstart', onMousedownDocument],\n        [window, 'resize', picker.place.bind(picker)]\n      ];\n      registerListeners(this, listeners);\n    }\n  }\n\n  /**\n   * Format Date object or time value in given format and language\n   * @param  {Date|Number} date - date or time value to format\n   * @param  {String|Object} format - format string or object that contains\n   * toDisplay() custom formatter, whose signature is\n   * - args:\n   *   - date: {Date} - Date instance of the date passed to the method\n   *   - format: {Object} - the format object passed to the method\n   *   - locale: {Object} - locale for the language specified by `lang`\n   * - return:\n   *     {String} formatted date\n   * @param  {String} [lang=en] - language code for the locale to use\n   * @return {String} formatted date\n   */\n  static formatDate(date, format, lang) {\n    return formatDate(date, format, lang && locales[lang] || locales.en);\n  }\n\n  /**\n   * Parse date string\n   * @param  {String|Date|Number} dateStr - date string, Date object or time\n   * value to parse\n   * @param  {String|Object} format - format string or object that contains\n   * toValue() custom parser, whose signature is\n   * - args:\n   *   - dateStr: {String|Date|Number} - the dateStr passed to the method\n   *   - format: {Object} - the format object passed to the method\n   *   - locale: {Object} - locale for the language specified by `lang`\n   * - return:\n   *     {Date|Number} parsed date or its time value\n   * @param  {String} [lang=en] - language code for the locale to use\n   * @return {Number} time value of parsed date\n   */\n  static parseDate(dateStr, format, lang) {\n    return parseDate(dateStr, format, lang && locales[lang] || locales.en);\n  }\n\n  /**\n   * @type {Object} - Installed locales in `[languageCode]: localeObject` format\n   * en`:_English (US)_ is pre-installed.\n   */\n  static get locales() {\n    return locales;\n  }\n\n  /**\n   * @type {Boolean} - Whether the picker element is shown. `true` whne shown\n   */\n  get active() {\n    return !!(this.picker && this.picker.active);\n  }\n\n  /**\n   * @type {HTMLDivElement} - DOM object of picker element\n   */\n  get pickerElement() {\n    return this.picker ? this.picker.element : undefined;\n  }\n\n  /**\n   * Set new values to the config options\n   * @param {Object} options - config options to update\n   */\n  setOptions(options) {\n    const picker = this.picker;\n    const newOptions = processOptions(options, this);\n    Object.assign(this._options, options);\n    Object.assign(this.config, newOptions);\n    picker.setOptions(newOptions);\n\n    refreshUI(this, 3);\n  }\n\n  /**\n   * Show the picker element\n   */\n  show() {\n    if (this.inputField) {\n      if (this.inputField.disabled) {\n        return;\n      }\n      if (!isActiveElement(this.inputField) && !this.config.disableTouchKeyboard) {\n        this._showing = true;\n        this.inputField.focus();\n        delete this._showing;\n      }\n    }\n    this.picker.show();\n  }\n\n  /**\n   * Hide the picker element\n   * Not available on inline picker\n   */\n  hide() {\n    if (this.inline) {\n      return;\n    }\n    this.picker.hide();\n    this.picker.update().changeView(this.config.startView).render();\n  }\n\n  /**\n   * Destroy the Datepicker instance\n   * @return {Detepicker} - the instance destroyed\n   */\n  destroy() {\n    this.hide();\n    unregisterListeners(this);\n    this.picker.detach();\n    if (!this.inline) {\n      this.inputField.classList.remove('datepicker-input');\n    }\n    delete this.element.datepicker;\n    return this;\n  }\n\n  /**\n   * Get the selected date(s)\n   *\n   * The method returns a Date object of selected date by default, and returns\n   * an array of selected dates in multidate mode. If format string is passed,\n   * it returns date string(s) formatted in given format.\n   *\n   * @param  {String} [format] - Format string to stringify the date(s)\n   * @return {Date|String|Date[]|String[]} - selected date(s), or if none is\n   * selected, empty array in multidate mode and untitled in sigledate mode\n   */\n  getDate(format = undefined) {\n    const callback = format\n      ? date => formatDate(date, format, this.config.locale)\n      : date => new Date(date);\n\n    if (this.config.multidate) {\n      return this.dates.map(callback);\n    }\n    if (this.dates.length > 0) {\n      return callback(this.dates[0]);\n    }\n  }\n\n  /**\n   * Set selected date(s)\n   *\n   * In multidate mode, you can pass multiple dates as a series of arguments\n   * or an array. (Since each date is parsed individually, the type of the\n   * dates doesn't have to be the same.)\n   * The given dates are used to toggle the select status of each date. The\n   * number of selected dates is kept from exceeding the length set to\n   * maxNumberOfDates.\n   *\n   * With clear: true option, the method can be used to clear the selection\n   * and to replace the selection instead of toggling in multidate mode.\n   * If the option is passed with no date arguments or an empty dates array,\n   * it works as \"clear\" (clear the selection then set nothing), and if the\n   * option is passed with new dates to select, it works as \"replace\" (clear\n   * the selection then set the given dates)\n   *\n   * When render: false option is used, the method omits re-rendering the\n   * picker element. In this case, you need to call refresh() method later in\n   * order for the picker element to reflect the changes. The input field is\n   * refreshed always regardless of this option.\n   *\n   * When invalid (unparsable, repeated, disabled or out-of-range) dates are\n   * passed, the method ignores them and applies only valid ones. In the case\n   * that all the given dates are invalid, which is distinguished from passing\n   * no dates, the method considers it as an error and leaves the selection\n   * untouched. (The input field also remains untouched unless revert: true\n   * option is used.)\n   *\n   * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date\n   * objects, time values or mix of those for new selection\n   * @param {Object} [options] - function options\n   * - clear: {boolean} - Whether to clear the existing selection\n   *     defualt: false\n   * - render: {boolean} - Whether to re-render the picker element\n   *     default: true\n   * - autohide: {boolean} - Whether to hide the picker element after re-render\n   *     Ignored when used with render: false\n   *     default: config.autohide\n   * - revert: {boolean} - Whether to refresh the input field when all the\n   *     passed dates are invalid\n   *     default: false\n   */\n  setDate(...args) {\n    const dates = [...args];\n    const opts = {};\n    const lastArg = lastItemOf(args);\n    if (\n      typeof lastArg === 'object'\n      && !Array.isArray(lastArg)\n      && !(lastArg instanceof Date)\n      && lastArg\n    ) {\n      Object.assign(opts, dates.pop());\n    }\n\n    const inputDates = Array.isArray(dates[0]) ? dates[0] : dates;\n    setDate(this, inputDates, opts);\n  }\n\n  /**\n   * Update the selected date(s) with input field's value\n   * Not available on inline picker\n   *\n   * The input field will be refreshed with properly formatted date string.\n   *\n   * In the case that all the entered dates are invalid (unparsable, repeated,\n   * disabled or out-of-range), whixh is distinguished from empty input field,\n   * the method leaves the input field untouched as well as the selection by\n   * default. If revert: true option is used in this case, the input field is\n   * refreshed with the existing selection.\n   *\n   * @param  {Object} [options] - function options\n   * - autohide: {boolean} - whether to hide the picker element after refresh\n   *     default: false\n   * - revert: {boolean} - Whether to refresh the input field when all the\n   *     passed dates are invalid\n   *     default: false\n   */\n  update(options = undefined) {\n    if (this.inline) {\n      return;\n    }\n\n    const opts = Object.assign(options || {}, {clear: true, render: true});\n    const inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);\n    setDate(this, inputDates, opts);\n  }\n\n  /**\n   * Refresh the picker element and the associated input field\n   * @param {String} [target] - target item when refreshing one item only\n   * 'picker' or 'input'\n   * @param {Boolean} [forceRender] - whether to re-render the picker element\n   * regardless of its state instead of optimized refresh\n   */\n  refresh(target = undefined, forceRender = false) {\n    if (target && typeof target !== 'string') {\n      forceRender = target;\n      target = undefined;\n    }\n\n    let mode;\n    if (target === 'picker') {\n      mode = 2;\n    } else if (target === 'input') {\n      mode = 1;\n    } else {\n      mode = 3;\n    }\n    refreshUI(this, mode, !forceRender);\n  }\n\n  /**\n   * Enter edit mode\n   * Not available on inline picker or when the picker element is hidden\n   */\n  enterEditMode() {\n    if (this.inline || !this.picker.active || this.editMode) {\n      return;\n    }\n    this.editMode = true;\n    this.inputField.classList.add('in-edit');\n  }\n\n  /**\n   * Exit from edit mode\n   * Not available on inline picker\n   * @param  {Object} [options] - function options\n   * - update: {boolean} - whether to call update() after exiting\n   *     If false, input field is revert to the existing selection\n   *     default: false\n   */\n  exitEditMode(options = undefined) {\n    if (this.inline || !this.editMode) {\n      return;\n    }\n    const opts = Object.assign({update: false}, options);\n    delete this.editMode;\n    this.inputField.classList.remove('in-edit');\n    if (opts.update) {\n      this.update(opts);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}